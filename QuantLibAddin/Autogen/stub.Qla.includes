#if defined(HAVE_CONFIG_H)     // Dynamically created by configure
    #include <qla/config.hpp>
#endif

#include <qla/typeregistry.hpp>
#include <ql/Currencies/all.hpp>
#include <ql/interestrate.hpp>
#include <ql/DayCounters/all.hpp>
#include <ql/Calendars/all.hpp>
#include <ql/Instruments/asianoption.hpp>
#include <ql/Instruments/basketoption.hpp>
#include <ql/Instruments/barrieroption.hpp>

#define REG_ENUM(Type, Body) \
    { \
        TypeMapPtr typeMap(new TypeMap); \
        Body \
        allTypesMap[typeid(Type).name()] = typeMap; \
    }

#define MAP(str_id, constructor) \
    (*typeMap)[str_id] = new constructor

namespace QuantLibAddin {

    std::vector<std::string> Registry::getAllRegisteredTypes() const {
        std::vector<std::string> ret;
        for(std::map<std::string, TypeMapPtr>::const_iterator i = allTypesMap.begin(); i != allTypesMap.end();++i)
            ret.push_back(i->first);
        return ret;
    }

    std::vector<std::string> Registry::getTypeElements(const std::string& id) const {
        std::map<std::string, TypeMapPtr>::const_iterator map = allTypesMap.find(id);
        QL_REQUIRE(map != allTypesMap.end(), "EnumTypeFactory::getEnumElements: invalid enum id: " + id);
        std::vector<std::string> ret;
        for(TypeMap::const_iterator i = map->second->begin(); i != map->second->end(); ++i)
            ret.push_back(i->first);
        return ret;
    }

    EnumRegistry::EnumRegistry() {

