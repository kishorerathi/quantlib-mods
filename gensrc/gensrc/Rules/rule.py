
"""
 Copyright (C) 2005, 2006, 2007 Eric Ehlers
 Copyright (C) 2005 Plamen Neykov
 Copyright (C) 2005 Aurelien Chanudet

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it under the
 terms of the QuantLib license.  You should have received a copy of the
 license along with this program; if not, please email quantlib-dev@lists.sf.net
 The license is also available online at http://quantlib.org/html/license.html

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

from gensrc.Rules import exceptions
from gensrc.Configuration import environment
from gensrc.Serialization import serializable
from gensrc.Utilities import common
import code

"""Algorithms required to generate the source code for a given function 
parameter in a given context."""

def getCode(codeID):
    if code.__dict__.has_key(codeID):
        return code.__dict__[codeID]
    else:
        raise exceptions.RuleCodeInvalidException(codeID)

class Rule(serializable.Serializable):
    """the subset of a Rule pertaining to one or more tensor ranks."""

    groupName = 'Rules'

    tensorRank = None
    superType = None
    nativeType = None
    type = None
    default = None
    loop = None
    codeID = None
    vectorIterator = None
    const = None

    def serialize(self, serializer):
        """load/unload class state to/from serializer object."""
        serializer.serializeAttribute(self, common.TENSOR_RANK)
        serializer.serializeAttribute(self, common.SUPER_TYPE)
        serializer.serializeAttribute(self, common.NATIVE_TYPE)
        serializer.serializeAttribute(self, common.TYPE)
        serializer.serializeAttribute(self, common.VECTOR_ITERATOR)
        # FIXME change serializeAttributeBoolean() to have default value = None
        serializer.serializeAttributeBoolean(self, common.DEFAULT, None)
        serializer.serializeAttributeBoolean(self, common.LOOP, None)
        serializer.serializeAttributeBoolean(self, common.CONST, None)
        serializer.serializeAttribute(self, 'codeID')
        serializer.serializeValue(self)

    def postSerialize(self):
        """Perform post serialization initialization."""
        if self.codeID:
            self.code = getCode(self.codeID)
        else:
            self.code = self.value

    def match(self, param):
        return (self.tensorRank == None or self.tensorRank == param.tensorRank) \
            and (self.superType == None or self.superType == param.dataType.superType) \
            and (self.nativeType == None or self.nativeType == param.dataType.nativeType) \
            and (self.type == None or self.type == param.dataType.value) \
            and (self.vectorIterator == None or self.vectorIterator == param.vectorIterator) \
            and (self.default == None or self.default == bool(param.default)) \
            and (self.loop == None or self.loop == bool(param.loop)) \
            and (self.const == None or self.const == bool(param.const))

    def printDebug(self):
        print self.tensorRank, self.superType, self.nativeType, self.type, \
            self.default, self.loop, self.code

class Wrap(serializable.Serializable):
    """A class to process the 'wrap' text for a rule.  If this class
    is specified in the XML, then ParameterList will invoke it after the
    Rule is processed e.g.
        T = W % R
    where R is the text derived from Rule, W is the value of Wrap, and
    T is the final text to be returned to the Addin.

    This can be used e.g. when the autogenerated code needs to be prefixed
    and/or suffixed with comments."""

    name = 'Wrap'

    def serialize(self, serializer):
        """load/unload class state to/from serializer object."""
        serializer.serializeValue(self)
        serializer.serializeAttribute(self, 'codeID')

    def postSerialize(self):
        if self.codeID:
            self.text = getCode(self.codeID)
        else:
            self.text = self.value

class RuleGroup(serializable.Serializable):
    """This class encapsulates an algorithm required to generate the source
    code for a given function parameter in a given context."""

    groupName = 'RuleGroups'

    def serialize(self, serializer):
        """Load/unload class state to/from serializer object."""
        serializer.serializeAttribute(self, common.NAME)
        serializer.serializeAttribute(self, common.DELIM, '')
        serializer.serializeAttributeBoolean(self, common.CHECK_PARAM_IGNORE)
        serializer.serializeAttributeBoolean(self, common.CHECK_SKIP_FIRST)
        serializer.serializeAttributeBoolean(self, common.PAD_LAST_PARAM, False)
        serializer.serializeAttributeInteger(self, common.INDENT, 0)
        serializer.serializeObject(self, Wrap, True)
        serializer.serializeObjectList(self, Rule)

    def postSerialize(self):
        """Perform post serialization initialization."""
        self.indent *= 4 * ' '
        if self.Wrap:
            self.wrapText = self.Wrap.text
        else:
            self.wrapText = None

    def apply(self, param):
        """Apply all available Rules to given parameter."""

        if self.checkParameterIgnore and param.ignore: return

        if self.padLastParamDesc and param.lastParameter:
            self.paramDesc = param.description + '  '
        else:
            self.paramDesc = param.description

        self.param = param

        if self.applyRule():
            return self.invokeRule()

    def applyRule(self):
        '''Apply the Rule, if any, which matches the given parameter'''
        for ruleItem in self.Rules:
            if ruleItem.match(self.param):
                self.ruleResult = ruleItem.code
                return self.ruleResult != None

    def invokeRule(self):
        return self.ruleResult % {
            'classname' : self.param.dataType.classname,
            common.DEFAULT_VALUE : self.param.default,
            common.DESC_LEN : len(self.paramDesc),
            common.DESCRIPTION : self.paramDesc,
            common.INDENT2 : self.indent + '    ',
            common.INDENT : self.indent,
            common.NAME : self.param.name,
            common.NAMESPACE_LIB : environment.config().namespaceLibrary,
            common.NAMESPACE_OBJ : environment.config().namespaceObjects,
            common.NATIVE_TYPE : self.param.dataType.nativeType,
            common.SUPER_TYPE : self.param.dataType.superType,
            common.TENSOR_RANK : self.param.tensorRank,
            common.TYPE : self.param.dataType.value }

    def printDebug(self):
        print "debug rule group *****"
        print self.name, self.delimiter, self.checkParameterIgnore, \
            self.checkSkipFirst, self.indent
        for ruleItem in self.Rules:
            print "print rule item: *****"
            ruleItem.printDebug()

