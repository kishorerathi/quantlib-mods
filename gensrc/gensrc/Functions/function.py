
"""
 Copyright (C) 2005, 2006, 2007 Eric Ehlers
 Copyright (C) 2005 Plamen Neykov
 Copyright (C) 2005 Aurelien Chanudet

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it under the
 terms of the QuantLib license.  You should have received a copy of the
 license along with this program; if not, please email quantlib-dev@lists.sf.net
 The license is also available online at http://quantlib.org/html/license.html

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

"""Encapsulate state and behavior required to generate source code for a
function."""

from gensrc.Utilities import common
from gensrc.Utilities import buffer
from gensrc.Serialization import serializable
from gensrc.Functions import behavior
from gensrc.Parameters import parameterlist
from gensrc.Parameters import parameter
from gensrc.Configuration import environment

# possible states for the implementation of a function on a given platform
DOC_ONLY = 0    # only autogenerate documentation for this function - no code
MANUAL = 1      # function hand-written - registration may be autogenerated
AUTO = 2        # autogenerate all code and documentation (the default)

class SupportedPlatform(serializable.Serializable):
    """Define the implementation of a particular function on a particular 
    platform."""

    groupName_ = 'SupportedPlatforms'

    # map to take the implementation as a string loaded from XML metadata
    # and convert it to one of the constants defined above
    implStrToInt = {
        'documentationOnly' : DOC_ONLY,
        'manual' : MANUAL,
        'auto' : AUTO }

    def serialize(self, serializer):
        """Load/unload class state to/from serializer object."""
        serializer.serializeAttribute(self, 'implementation', 'auto')
        serializer.serializeAttributeBoolean(self, 'xlMacro', True)
        serializer.serializeAttributeBoolean(self, common.CALC_IN_WIZ, False)
        serializer.serializeAttribute(self, common.NAME)

    def postSerialize(self):
        self.implNum_ = SupportedPlatform.implStrToInt[self.implementation_]

    def implNum(self):
        return self.implNum_

    def xlMacro(self):
        return self.xlMacro_

    def calcInWizard(self):
        return self.calcInWizard_

class Function(serializable.Serializable):
    """Encapsulate state and behavior required
    to generate source code for a function."""

    groupName_ = 'Functions'
    loopParameter_ = None
    enumeration_ = None
    resetCaller_ = ''
    generateVOs_ = False
    validatePermanent_ = ''
    XL_WIZ_CHECK = '''
        if (functionCall.IsCalledByFuncWiz())
            return 0;'''
    VALIDATE_TRIGGER = '''
        ObjHandler::validateRange(trigger, "trigger");'''

    def serialize(self, serializer):
        """Load/unload class state to/from serializer object."""
        serializer.serializeAttribute(self, common.NAME)
        serializer.serializeProperty(self, common.DESCRIPTION)
        serializer.serializeProperty(self, common.LONG_DESC, self.description_)
        serializer.serializeObjectDict(self, SupportedPlatform)
        # FIXME get rid of reference to QLA
        serializer.serializeProperty(self, common.ALIAS, 'QuantLibAddin::' + self.name_)
        serializer.serializeObject(self, parameterlist.ParameterList)
        serializer.serializeBoolean(self, common.DOCUMENTATION_ONLY)
        serializer.serializeAttributeBoolean(self, common.TRIGGER, True)

    def postSerialize(self):
        # some fields required for the Excel addin
        if self.xlCalcInWizard():
            self.xlWizardCheck_ = ''
        else:
            self.xlWizardCheck_ = Function.XL_WIZ_CHECK
        if self.dependencyTrigger_:
            self.xlTrigger_ = Function.VALIDATE_TRIGGER
        else:
            self.xlTrigger_ = ''

    def platformSupported(self, platformName, implementation):
        """Determine whether this function supported by given platform."""
        return self.supportedPlatforms_.has_key(platformName) \
            and self.supportedPlatforms_[platformName].implNum() >= implementation

    def xlMacro(self):
        """Determine whether this function requires macro on excel platform."""
        return self.supportedPlatforms_.has_key('Excel') \
            and self.supportedPlatforms_['Excel'].xlMacro()

    def xlCalcInWizard(self):
        """Determine whether this function should be enabled under excel wizard."""
        return self.supportedPlatforms_.has_key('Excel') \
            and self.supportedPlatforms_['Excel'].calcInWizard()

    def generateVO(self, addin): return "/* no VO - not a constructor*/"

    def parameterList(self):
        return self.parameterList_

    def loopParameter(self):
        return self.loopParameter_

    def returnValue(self):
        return self.returnValue_

    def parameterObjectID(self):
        return self.parameterObjectID_

    def alias(self):
        return self.alias_

    def deref(self):
        return self.deref_

    def type(self):
        return self.type_

    def libraryFunction(self):
        return self.libraryFunction_

    def generateVOs(self):
        return self.generateVOs_

    def description(self):
        return self.description_

    def longDescription(self):
        return self.longDescription_

    def xlTrigger(self):
        return self.xlTrigger_

    def xlWizardCheck(self):
        return self.xlWizardCheck_

    def validatePermanent(self):
        return self.validatePermanent_

    def resetCaller(self):
        return self.resetCaller_

    def behavior(self):
        return self.behavior_

    def printDebug(self):
        self.parameterList_.printDebug()

class Constructor(Function):
    """Function which constructs a QuantLib object."""

    resetCaller_ = 'true'
    generateVOs_ = True
    funcCtorBuffer_ = None
    validatePermanent_ = '''
        ObjHandler::validateRange(permanent, "permanent");'''
    SET_PERMANENT = '''
        if (permanentCpp)
            objectPointer->setPermanent();'''
    VO_CALL = '''
        objectPointer->setProperties(
            boost::shared_ptr<ObjHandler::ValueObject>(
            new %(namespaceObjects)s::ValueObjects::%(functionName)s(%(parameterList)s)));'''
    DESCRIPTION = 'Construct an object of class %s and return its id'

    def __init__(self):
        self.returnValue_ = parameter.ConstructorReturnValue()
        # FIXME put this back into class vars
        if not Constructor.funcCtorBuffer_:
            Constructor.funcCtorBuffer_ = buffer.loadBuffer('stub.func.constructor')

    def serialize(self, serializer):
        """Load/unload class state to/from serializer object."""
        super(Constructor, self).serialize(serializer)
        serializer.serializeProperty(self, common.LIBRARY_FUNCTION)

    def postSerialize(self):
        """Perform post serialization initialization."""
        Function.postSerialize(self)
        # implicit in the definition of a Constructor is that the first parameter
        # is a string to be used as the objectID of the new object
        self.parameterList_.prepend(parameter.ConstructorObjectID())
        # All ctors have a final optional boolean parameter 'permanent'
        self.parameterList_.append(parameter.PermanentFlag())
        # dependency tracking trigger
        if self.dependencyTrigger_:
            self.parameterList_.append(parameter.DependencyTrigger())
        self.description_ = Constructor.DESCRIPTION % self.libraryFunction_
        if not self.longDescription_: self.longDescription_ = self.description_

    def generateBody(self, addin):
        """Generate source code for function body."""
        if addin.voSupported():
            setPermanent = addin.convertPermanentFlag() + Constructor.SET_PERMANENT
            voCall = Constructor.VO_CALL % {
                'functionName' : self.name_,
                'namespaceObjects' : environment.config().namespaceObjects(),
                'parameterList' : self.parameterList_.generate(addin.voCall())}
        else:
            setPermanent = ''
            voCall = ''
        return Constructor.funcCtorBuffer_ % {
            'libraryFunction' : self.libraryFunction_,
            'namespaceObjects' : environment.config().namespaceObjects(),
            'parameterList' : self.parameterList_.generate(addin.libraryCall()), 
            'setPermanent' : setPermanent, 
            'suffix' : addin.objectIdSuffix(), 
            'voCall' : voCall}

    def libraryFunction(self):
        return self.libraryFunction_

class Member(Function):
    """Function which invokes member function of existing QuantLib object."""

    deref_ = '->'

    def serialize(self, serializer):
        """Load/unload class state to/from serializer object."""
        super(Member, self).serialize(serializer)
        serializer.serializeProperty(self, common.LIBRARY_FUNCTION)
        serializer.serializeAttribute(self, common.TYPE)
        serializer.serializeAttribute(self, 'superType')
        serializer.serializeAttribute(self, common.LOOP_PARAMETER)
        serializer.serializeObject(self, parameter.ReturnValue)

    def postSerialize(self):
        """Perform post serialization initialization."""
        Function.postSerialize(self)
        # implicit in the definition of a Member is that the first parameter
        # is the objectID of the object to be retrieved

        # FIXME rework so not necessary to retain "self.parameterObjectID"
        # as reference to first parameter
        self.parameterObjectID_ = parameter.MemberObjectID(self.type_, self.superType_)
        self.parameterList_.prepend(self.parameterObjectID_)
        # dependency tracking trigger
        if self.dependencyTrigger_:
            self.parameterList_.append(parameter.DependencyTrigger())
        # determine behavior (normal or loop)
        if self.loopParameter_:
            self.behavior_ = behavior.BehaviorMemberLoop(self)
        else:
            self.behavior_ = behavior.BehaviorMemberNormal(self)

    def generateBody(self, addin):
        """Generate source code for the body of the function."""
        return self.behavior_.generateBody(addin)

class EnumerationMember(Member):
    """Function which invokes member function of Enumeration from the Registry."""
    deref_ = '.'

    def serialize(self, serializer):
        """Load/unload class state to/from serializer object."""
        super(EnumerationMember, self).serialize(serializer)

    def postSerialize(self):
        """Perform post serialization initialization."""
        Function.postSerialize(self)
        # implicit in the definition of an EnumerationMember is that the first parameter
        # is the ID of the enumeration to be retrieved

        # FIXME rework so not necessary to retain "self.parameterObjectID"
        # as reference to first parameter
        self.parameterObjectID_ = parameter.EnumerationId(self.type_, self.superType_)
        self.parameterList_.prepend(self.parameterObjectID_)
        # dependency tracking trigger
        if self.dependencyTrigger_:
            self.parameterList_.append(parameter.DependencyTrigger())
        # determine behavior (normal or loop)
        if self.loopParameter_:
            self.behavior_ = behavior.BehaviorEnumerationLoop(self) 
        else:
            self.behavior_ = behavior.BehaviorMemberNormal(self)

class Procedure(Function):
    """Procedural function not associated with any QuantLib object."""

    def serialize(self, serializer):
        """Load/unload class state to/from serializer object."""
        super(Procedure, self).serialize(serializer)
        serializer.serializeObject(self, parameter.ReturnValue)
        serializer.serializeAttribute(self, common.LOOP_PARAMETER)

    def postSerialize(self):
        """Perform post serialization initialization."""
        Function.postSerialize(self)
        # dependency tracking trigger
        if self.dependencyTrigger_:
            self.parameterList_.append(parameter.DependencyTrigger())
        # determine behavior (normal or loop)
        if self.loopParameter_:
            self.behavior_ = behavior.BehaviorProcedureLoop(self) 
        else:
            self.behavior_ = behavior.BehaviorProcedureNormal(self)

    def generateBody(self, addin):
        """Generate source code for the body of the function."""
        return self.behavior_.generateBody(addin)

