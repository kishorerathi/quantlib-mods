#include <fstream>
#include <boost/archive/xml_iarchive.hpp>
#include <boost/archive/xml_oarchive.hpp>
#include <boost/serialization/shared_ptr.hpp>
#include <boost/serialization/vector.hpp>
#include <%(addinDirectory)s/Serialization/serializationfactory.hpp>
#include <%(addinDirectory)s/Serialization/serialization_all.hpp>
#include <oh/repository.hpp>
#include <boost/filesystem.hpp>

namespace %(namespaceAddin)s {

    SerializationFactory &SerializationFactory::instance() {
        if (instance_) {
            SerializationFactory *ret = dynamic_cast<SerializationFactory*>(instance_);
            if (ret) return *ret;
        }
        OH_FAIL("Attempt to reference uninitialized SerializationFactory object");
    }

    template<class Archive>
    void tpl_register_classes(Archive& ar) {
    
            // ObjectHandler

            register_oh(ar);
    
%(bufferRegister)s
    }

    void register_in(boost::archive::xml_iarchive& ia) {
        %(callBaseIn)s
        tpl_register_classes(ia);
    }

    void register_out(boost::archive::xml_oarchive& oa) {
        %(callBaseOut)s
        tpl_register_classes(oa);
    }


    void SerializationFactory::saveObject(
        const boost::shared_ptr<ObjectHandler::Object> &object,
        const char *path) const {

        std::ofstream ofs(path);
        boost::archive::xml_oarchive oa(ofs);
        register_out(oa);
        oa << boost::serialization::make_nvp("oh_object", object->properties());
    }

    void SerializationFactory::saveObject(
        const std::vector<boost::shared_ptr<ObjectHandler::Object> >& objectList,
        const char *path) const {

        std::ofstream ofs(path);
        boost::archive::xml_oarchive oa(ofs);
        register_out(oa);
        std::vector<boost::shared_ptr<ObjectHandler::Object> >::const_iterator i;
        for (i=objectList.begin(); i!=objectList.end(); ++i){
            // We need to supply a name for the object to be serialized.
            // The objectID isn't suitable because certain values of objectID are
            // invalid as XML tags e.g. values beginning with numeric characters.
            // For our purposes the tag is ignored, so just supply a dummy string.
            //std::string objectID = boost::any_cast<std::string>(valueObject->getProperty("objectID"));
            //oa << boost::serialization::make_nvp(objectID.c_str(), valueObject);
            oa << boost::serialization::make_nvp("oh_object", (*i)->properties());
        }
    }

    void SerializationFactory::saveObject2(
        const std::vector<boost::shared_ptr<ObjectHandler::Object> >& objectList,
        const char *path) const {

        std::vector<boost::shared_ptr<ObjectHandler::ValueObject> > valueObjects;
        std::vector<boost::shared_ptr<ObjectHandler::Object> >::const_iterator i;
        for (i=objectList.begin(); i!=objectList.end(); ++i)
            valueObjects.push_back((*i)->properties());

        std::ofstream ofs(path);
        boost::archive::xml_oarchive oa(ofs);
        register_out(oa);
        oa << boost::serialization::make_nvp("object_list", valueObjects);
    }

    boost::shared_ptr<ObjectHandler::Object> SerializationFactory::loadObject(
        const std::string &objectID,
        const char *path) const {

        std::ifstream ifs(path);
        boost::archive::xml_iarchive ia(ifs);
        register_in(ia);
        boost::shared_ptr<ObjectHandler::ValueObject> valueObject;
        ia >> boost::serialization::make_nvp(objectID.c_str(), valueObject);
        // This VO has picked up the ID of the old VO that was deserialized.
        // Override this value with the new ID supplied by the caller.
        valueObject->setProperty("objectID", objectID);
        CreatorMap::const_iterator j = creatorMap_().find(valueObject->className());
        OH_REQUIRE(j != creatorMap_().end(), "No creator for class " << valueObject->className());
        Creator creator = j->second;
        boost::shared_ptr<ObjectHandler::Object> object = creator(valueObject);
        ObjectHandler::Repository::instance().storeObject(objectID, object);
        return object;
    }

    std::vector<boost::shared_ptr<ObjectHandler::Object> > SerializationFactory::loadObject(
        const std::vector<std::string> &idList,
        const char *path) const {

        std::vector<boost::shared_ptr<ObjectHandler::Object> > returnValues;
        std::ifstream ifs(path);
        boost::archive::xml_iarchive ia(ifs);
        register_in(ia);

        std::vector<std::string>::const_iterator i;
        for (i=idList.begin(); i!=idList.end(); ++i) {
            boost::shared_ptr<ObjectHandler::ValueObject> valueObject;
            ia >> boost::serialization::make_nvp(i->c_str(), valueObject);
            // This VO has picked up the ID of the old VO that was deserialized.
            // Override this value with the new ID supplied by the caller.
            valueObject->setProperty("objectID", *i);
            CreatorMap::const_iterator j = creatorMap_().find(valueObject->className());
            OH_REQUIRE(j != creatorMap_().end(), "No creator for class " << valueObject->className());
            Creator creator = j->second;
            boost::shared_ptr<ObjectHandler::Object> object = creator(valueObject);
            ObjectHandler::Repository::instance().storeObject(*i, object);
            returnValues.push_back(object);
        }
        return returnValues;
    }

    void SerializationFactory::processPath(
        const std::string &path,
        std::vector<boost::shared_ptr<ObjectHandler::Object> > &returnValues) const {

        std::ifstream ifs(path.c_str());
        boost::archive::xml_iarchive ia(ifs);
        register_in(ia);

        std::vector<boost::shared_ptr<ObjectHandler::ValueObject> > valueObjects;
        ia >> boost::serialization::make_nvp("object_list", valueObjects);

        std::vector<boost::shared_ptr<ObjectHandler::ValueObject> >::const_iterator i;
        for (i=valueObjects.begin(); i!=valueObjects.end(); ++i) {
            CreatorMap::const_iterator j = creatorMap_().find((*i)->className());
            OH_REQUIRE(j != creatorMap_().end(), "No creator for class " << (*i)->className());
            Creator creator = j->second;
            boost::shared_ptr<ObjectHandler::Object> object = creator(*i);
            std::string objectID = boost::any_cast<std::string>((*i)->getProperty("objectID"));
            ObjectHandler::Repository::instance().storeObject(objectID, object);
            returnValues.push_back(object);
        }
    }
        
    std::vector<boost::shared_ptr<ObjectHandler::Object> > SerializationFactory::loadObject2(
        const char *path) const {

        OH_REQUIRE(boost::filesystem::exists(path), "Invalid path : " << path);

        std::vector<boost::shared_ptr<ObjectHandler::Object> > returnValues;

        if (boost::filesystem::is_directory(path)) {
            for (boost::filesystem::directory_iterator itr(path); 
                itr!=boost::filesystem::directory_iterator(); ++itr) {
                processPath(itr->path().string(), returnValues);
            }
        } else {
            processPath(path, returnValues);
        }

        return returnValues;
    }

}

