#include <fstream>
#include <boost/archive/xml_iarchive.hpp>
#include <boost/archive/xml_oarchive.hpp>
#include <boost/serialization/shared_ptr.hpp>
#include <%(addinDirectory)s/Serialization/serializationfactory.hpp>
#include <%(addinDirectory)s/Serialization/serialization_all.hpp>
#include <oh/repository.hpp>

namespace %(namespaceAddin)s {

    SerializationFactory &SerializationFactory::instance() {
        if (instance_) {
            SerializationFactory *ret = dynamic_cast<SerializationFactory*>(instance_);
            if (ret) return *ret;
        }
        OH_FAIL("Attempt to reference uninitialized SerializationFactory object");
    }

    template<class Archive>
    void tpl_register_classes(Archive& ar) {
    
            // ObjectHandler

            register_oh(ar);
    
%(bufferRegister)s
    }

    void register_in(boost::archive::xml_iarchive& ia) {
		%(callBaseIn)s
		tpl_register_classes(ia);
	}

    void register_out(boost::archive::xml_oarchive& oa) {
		%(callBaseOut)s
		tpl_register_classes(oa);
	}


	void SerializationFactory::saveObject(const boost::shared_ptr<ObjectHandler::Object> &object, const char *path) const {
        std::ofstream ofs(path);
        boost::archive::xml_oarchive oa(ofs);
        register_out(oa);
		oa << boost::serialization::make_nvp("oh_object", object->properties());
	}

    void SerializationFactory::saveObject(
		const std::vector<boost::shared_ptr<ObjectHandler::Object> >& objectList,
		const char *path) const {

        std::ofstream ofs(path);
        boost::archive::xml_oarchive oa(ofs);
        register_out(oa);
		for(std::vector<boost::shared_ptr<ObjectHandler::Object> >::const_iterator i=objectList.begin();i!=objectList.end();++i){
			// We need to supply a name for the object to be serialized.
			// The objectID isn't suitable because certain values of objectID are
			// invalid as XML tags e.g. values beginning with numeric characters.
			// For our purposes the tag is ignored, so just supply a dummy string.
			//std::string objectID = boost::any_cast<std::string>(valueObject->getProperty("objectID"));
			//oa << boost::serialization::make_nvp(objectID.c_str(), valueObject);
			oa << boost::serialization::make_nvp("oh_object", (*i)->properties());
		}
    }

	boost::shared_ptr<ObjectHandler::Object> SerializationFactory::loadObject(const std::string &objectID, const char *path) const {
        std::ifstream ifs(path);
        boost::archive::xml_iarchive ia(ifs);
        register_in(ia);
		boost::shared_ptr<ObjectHandler::ValueObject> valueObject;
		ia >> boost::serialization::make_nvp(objectID.c_str(), valueObject);
		// This VO has picked up the ID of the old VO that was deserialized.
		// Override this value with the new ID supplied by the caller.
		valueObject->setProperty("objectID", objectID);
		CreatorMap::const_iterator j = creatorMap_().find(valueObject->className());
		OH_REQUIRE(j != creatorMap_().end(), "No creator for class " << valueObject->className());
		Creator creator = j->second;
		boost::shared_ptr<ObjectHandler::Object> object = creator(valueObject);
		ObjectHandler::Repository::instance().storeObject(objectID, object);
		return object;
	}

	std::vector<boost::shared_ptr<ObjectHandler::Object> > SerializationFactory::loadObject(
        const std::vector<std::string> &idList, const char *path) const {

		std::vector<boost::shared_ptr<ObjectHandler::Object> > returnValues;
        std::ifstream ifs(path);
        boost::archive::xml_iarchive ia(ifs);
        register_in(ia);

		for(std::vector<std::string>::const_iterator i=idList.begin();i!=idList.end();++i){
			boost::shared_ptr<ObjectHandler::ValueObject> valueObject;
			ia >> boost::serialization::make_nvp(i->c_str(), valueObject);
			// This VO has picked up the ID of the old VO that was deserialized.
			// Override this value with the new ID supplied by the caller.
			valueObject->setProperty("objectID", *i);
			CreatorMap::const_iterator j = creatorMap_().find(valueObject->className());
			OH_REQUIRE(j != creatorMap_().end(), "No creator for class " << valueObject->className());
			Creator creator = j->second;
			boost::shared_ptr<ObjectHandler::Object> object = creator(valueObject);
			ObjectHandler::Repository::instance().storeObject(*i, object);
			returnValues.push_back(object);
		}
	    return returnValues;
	}
}

